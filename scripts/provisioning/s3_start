#!/usr/bin/env python3
#
# Copyright (c) 2021 Seagate Technology LLC and/or its Affiliates
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# For any questions about this software or licensing,
# please email opensource@seagate.com or cortx-questions@seagate.com.
#

import sys
import argparse
import traceback
import errno
import logging
import os
import socket
from logging import handlers
from s3confstore.cortx_s3_confstore import S3CortxConfStore

def main():
  """

  Main method takes care of calling
  a startup script of service given
  as a argument.

  """
  parser = argparse.ArgumentParser("S3server single entry command")
  parser.add_argument("--service", required=True)
  parser.add_argument("--index", required=False)
  parser.add_argument("-c", required=True)

  args = parser.parse_args()

  try:
    if not args.c:
      raise Exception("provide confstore_url")
    confstore_url = args.c

    # Load confstore file
    s3_confkeys_store = S3CortxConfStore\
        (f'yaml:///opt/seagate/cortx/s3/mini-prov/s3_prov_config.yaml', \
          's3_index')
    prov_confkeys_store = S3CortxConfStore(f'yaml://{confstore_url}', \
          'prov_index')
    machine_id = s3_confkeys_store.get_machine_id()

    # Get Config entries
    config_key = s3_confkeys_store.get_config\
                     ("CONFIG>CONFSTORE_BASE_CONFIG_PATH")
    config_path = prov_confkeys_store.get_config(config_key)
    logdir_key = s3_confkeys_store.get_config\
                     ("CONFIG>CONFSTORE_BASE_LOG_PATH")
    logdir_path = prov_confkeys_store.get_config(logdir_key)

    #Config path details
    s3config_path = os.path.join(config_path, "s3", "conf", "s3config.yaml")
    sysconfig_path = os.path.join(config_path, "s3", "sysconfig")

    #Logging path details
    s3_single_entry_log_directory = \
        os.path.join(logdir_path, "s3", machine_id, "s3deployment")
    s3_single_entry_log_file = \
        os.path.join(s3_single_entry_log_directory, "s3deployment.log")
    s3_single_entry_logger_name = \
        "s3deployment-logger-" + "[" + machine_id + "]"
    s3_single_entry_log_format = \
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

    create_logger_directory(s3_single_entry_log_directory)
    logger = create_logger(s3_single_entry_log_file, s3_single_entry_logger_name, s3_single_entry_log_format)

    if args.service == 's3server':
      if not args.index:
        raise Exception("provide instance id")
      fid_file = "s3server-" + args.index
      fid_path = os.path.join(sysconfig_path, fid_file)
      Fid = get_fid(fid_path)
      os.system(f"sh /opt/seagate/cortx/s3/s3startsystem.sh -F {Fid} -P {fid_path} -C {s3config_path} -d")
      os.system(f"tail -f {s3_single_entry_log_file}")
    elif args.service == 's3authserver':
      os.system(f"sh /opt/seagate/cortx/auth/startauth.sh {config_path}")
      s3_auth_log_path = os.path.join(logdir_path, "auth", machine_id, "server", "app.log")
      os.system(f"tail -f {s3_auth_log_path}")
    elif args.service == 's3bgproducer':
      os.system("sh /opt/seagate/cortx/s3/s3backgrounddelete/starts3backgroundproducer.sh")
    elif args.service == 's3bgconsumer':
      os.system("sh /opt/seagate/cortx/s3/s3backgrounddelete/starts3backgroundconsumer.sh")
    elif args.service == 'haproxy':
      os.system(f"sh /opt/seagate/cortx/s3/bin/starthaproxy.sh {config_path}")
      s3_haproxy_log_path = os.path.join(logdir_path, "s3", machine_id, "haproxy", "haproxy.log")
      os.system(f"tail -f {s3_haproxy_log_path}")
    else:
      logger.error(f"Invalid argument {args.service}")
  except Exception as e:
    logger.error(f"{str(e)}")
    logger.error(f"{traceback.format_exc()}")
    return errno.EINVAL

  return 0

def create_logger(s3_single_entry_log_file, s3_single_entry_logger_name, s3_single_entry_log_format):
    """Create logger, file handler, console handler and formatter."""
    # create logger with "S3 deployment logger"
    logger = logging.getLogger(s3_single_entry_logger_name)
    logger.setLevel(logging.DEBUG)
    # maxBytes 5242880 will allow base file s3_single_entry.log to rotate 
    # after every 5MB. With a backupCount of 5, files will be generated 
    # like s3_single_entry.log, s3_single_entry.log.1 and up to s3.log.5.
    # The file being written to is always s3_single_entry.log.
    fhandler = logging.handlers.RotatingFileHandler(s3_single_entry_log_file, \
                                                    mode='a',\
                                                    maxBytes = 5242880,\
                                                    backupCount = 5,\
                                                    encoding=None, delay=False)
    fhandler.setLevel(logging.DEBUG)

    # create console handler with a higher log level
    chandler = logging.StreamHandler(sys.stdout)
    chandler.setLevel(logging.DEBUG)

    formatter = logging.Formatter(s3_single_entry_log_format)

    # create formatter and add it to the handlers
    fhandler.setFormatter(formatter)
    chandler.setFormatter(formatter)

    # add the handlers to the logger
    logger.addHandler(fhandler)
    logger.addHandler(chandler)

    return logger

def create_logger_directory(s3_single_entry_log_directory):
    """Create log directory if not exsists."""
    _logger_directory = os.path.join(s3_single_entry_log_directory)
    if not os.path.isdir(_logger_directory):
        try:
            os.makedirs(_logger_directory)
        except OSError as e:
            if e.errno == errno.EEXIST:
                pass
            else:
                raise Exception("Startup Logger Could not be created")

def get_fid(fid_path):
    """ Get FID from FID file"""
    Fid = None
    with open(fid_path) as file1:
      Lines = file1.readlines()
      for line in Lines:
        if(line.startswith('MOTR_PROCESS_FID')):
          Fid = line.split("=")[1]
          break
    if not Fid:
      raise Exception("FID is not present in Fid path")
    Fid = Fid.strip("\n")
    Fid = Fid.strip("''")

    return Fid

if __name__ == '__main__':
  sys.exit(main())
